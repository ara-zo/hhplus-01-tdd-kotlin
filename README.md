## 개요

동시성 제어는 여러 사용자가 동시에 하나의 시스템에 접근하여 동일한 자원을 수정하려고 할 때 발생하는 문제를 방지하는 기술입니다.
포인트 충전 및 차감 기능을 많은 사용자가 동시에 이용할 때 동시성 제어가 적절히 적용되지 않으면 데이터 무결성에 문제가 발생할 수 있습니다.
따라서 안정적인 서비스 운영을 위해 동시성 제어는 필수적입니다.

## 왜 동시성 제어가 필요한가?

- 여러 사용자가 동시에 포인트 충전하거나 차감하는 상황에서 같은 데이터를 수정할 수 있음
- 데이터 수정 요청이 서로 겹치면 경쟁 상태(race condition) 가 발생하여 포인트 정보가 잘 못 될 수 있음
- 각각의 요청이 서로 다른 순간에 데이터베이스에 반영되면 충전된 포인트나 차감된 포인트가 예상과 다르게 적용될 수 있음
- 따라서 여러 요청이 동시에 들어오더라도 안전하게 데이터를 처리할 수 있도록 동시성 제어가 필수적!, 이를 통해 포인트 정보의 일관성과 무결성을 유지할 수 있음

## LockService 동작

`ReentrantLock`을 사용한 락 메커니즘을 도입하여 여러 요청이 동시에 들어올 때도 안정적으로 동작할 수 있도록 설계하였습니다.

`LockService`는 `ConcurrentHashMap`과 `ReentranLock`을 사용하여 각 사용자 ID별로 락을 생성하고, 요청이 들어왔을 때 해당 사용자에 대한 동시 작업을 제어 합니다.

- ConcurrentHashMap 사용
  각 사용자 ID에 대한 ReentrantLock 객체를 관리
  `computeIfAbsent`를 사용하여 해당 ID에 대한 락이 없으면 새롭게 생성하고 있으면 기존의 락을 재사용 합니다.
- ReentrantLock 사용
  `ReentrantLock(true)`로 공정성을 보장하는 락을 생성합니다. 여러 스레드가 동시에 락을 기다릴때 공정하게 대기열에 따라 락을 얻을 수 있도록 합니다.
- tryLock
  1분간 락을 시도, 만약 시간이 지나도 락을 얻지 못하면 예외를 던져 작업이 실패했다고 알려줍니다.
  성공적으로 락을 얻으면 다음 작업으로 넘어갑니다.
- finally
  작업이 끝난 후에는 `finally`에서 반드시 `unlock()`을 호출하여 락을 해제 합니다. 따라서 락을 사용한 뒤 별도로 `unlock()`을 호출하지 않아도 됩니다.

## 영향도(Impact / 기대 가치)

- 데이터 무결성 보장 : `LockService`를 통해 포인트 데이터가 동시 수정되는 상황을 방지함으로써 데이터의 무결성을 유지할 수 있습니다.
- 안정적인 사용자 경험 : 여러 사용자가 동시에 포인트를 충전하거나 사용할 때, 동시성 제어를 통해 충돌 없이 정확한 포인트 잔액을 조회하고 사용할 수 있게 되어 안정적인 사용자 경험을 제공합니다.
- 서비스 신뢰도 향상 : 포인트 시스템에서 오류가 발생하지 않도록 보장하여 사용자들이 시스템에 대한 신뢰도를 높일 수 있습니다.
- 확장성 대응 : 사용자가 증가하더라도 시스템이 동시성 문제를 일으키지 않고 안정적으로 운영될 수 있어, 확장 가능한 서비스로 발전할 수 있습니다.

## 문제점

- 성능 이슈 : `ReentrantLock`을 사용한 락 기반 동시성 제어는 높은 동시성 환경에서는 잠재적으로 성능에 영향을 줄 수 있습니다. 락을 사용할 경우, 여러 스레드가 동일한 리소스에 대해 기다려야 하기 때문에 성능 저하가 발생할 수 있습니다.

## 결론

현재 코드에서는 사용자별로 `ReentrantLock`을 이용해 동시성 제어를 하고 있습니다.

락이 잘 해제되는 구조와 충돌이 없는 처리가 보장되기 때문에 여러 요청이 들어오더라도 정상적으로 처리될 수 있을 것으로 보입니다.

다만, 성능이나 예외 처리 관련 요구사항에 따라 코드를 추가적으로 최적화하거나 개선할 필요가 있습니다.